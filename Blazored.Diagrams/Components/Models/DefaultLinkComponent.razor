@using Blazored.Diagrams.Services.Diagrams
@using Blazored.Diagrams.Services.Events
@implements IDisposable
@if (Link is not null)
{
    <svg style="width: 100%; height: 100%;overflow:visible;">
        <defs>
            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur"/>
                <feFlood flood-color="#C0C0C0" result="flood"/>
                <feComposite in="flood" in2="blur" operator="in" result="colorBlur"/>
                <feMerge>
                    <feMergeNode in="colorBlur"/>
                    <feMergeNode in="SourceGraphic"/>
                </feMerge>
            </filter>
        </defs>
        <path d="@GetPath()"
              style="pointer-events: auto"
              id="@(PathId)"
              fill="none"
              stroke="@_strokeColor"
              stroke-width="@(StrokeWidth)"
              @onpointerleave="HandlePointerLeave"
              @onpointerdown="HandlePointerDown"
              @onpointerenter="HandlePointerEnter"
              @onpointermove="HandlePointerMove"
              @onpointerup="HandlePointerUp"
              @onwheel="ctx => DiagramService.Events.Publish(new LinkWheelEvent(Link, ctx))"
              @onclick="HandleClick"
              @ondblclick="HandleDoubleClick"/>

    </svg>
}

@code {

    private string _strokeColor = null!;

    /// <summary>
    ///     Link to be rendered.
    /// </summary>
    [Parameter]
    public required Link Link { get; set; }

    /// <summary>
    /// Service cascaded through the <see cref="LinkContainer"/>
    /// </summary>
    [CascadingParameter]
    public IDiagramService DiagramService { get; set; } = null!;

    [Inject] private IJSRuntime Js { get; set; } = null!;

    /// <summary>
    ///     The <see cref="LinkContainer"/> that renders the component.
    /// </summary>
    [CascadingParameter]
    public required LinkContainer Container { get; set; }
    
    /// <summary>
    ///     Wave height when <see cref="DefaultLinkComponentPathType"/> is <see cref="DefaultLinkComponentPathType.Curved"/>.
    /// </summary>
    [Parameter] public int WaveHeight { get; set; } = 20;
    
    /// <summary>
    ///     Color of the link path. Default is black.
    /// </summary>
    [Parameter] public string StrokeColor { get; set; } = "black";

    /// <summary>
    /// Color of the link path when it's selected. Default is lightyellow.
    /// </summary>
    [Parameter] public string SelectedStrokeColor { get; set; } = "lightyellow";

    /// <summary>
    ///     Width of the path. Default is 4.
    /// </summary>
    [Parameter] public int StrokeWidth { get; set; } = 4;

    /// <summary>
    ///     Default link type when using the <see cref="DefaultLinkComponent"/>.
    ///     Will only be applied to newly created links.
    /// </summary>
    [Parameter] public DefaultLinkComponentPathType DefaultLinkComponentPathType { get; set; }

    
    /// <summary>
    ///     Function that generates a path when <see cref="DefaultLinkComponentPathType"/> is <see cref="Models.DefaultLinkComponentPathType.Custom"/>.
    /// </summary>
    [Parameter] public Func<string> CustomLinkPath  { get; set; } = null!;

    /// <summary>
    ///     ID of the element.
    /// </summary>
    public string PathId => $"link-path-{Link.Id}";

    private List<IDisposable> _subcriptions = [];

    /// <inheritdoc />
    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _subcriptions = [DiagramService.Events.SubscribeTo<LinkSelectionChangedEvent>(OnLinkSelectionChanged)];
            _strokeColor = Link.IsSelected ? SelectedStrokeColor : StrokeColor; 
        }
        return base.OnAfterRenderAsync(firstRender);
    }

    private void OnLinkSelectionChanged(LinkSelectionChangedEvent obj)
    {
        _strokeColor = obj.Model.IsSelected ? SelectedStrokeColor : StrokeColor; 
    }

    private async Task HandleClick(MouseEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkClickedEvent(Link, e));
        }
    }

    private async Task HandleDoubleClick(MouseEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkDoubleClickedEvent(Link, e));
        }
    }

    private async Task HandlePointerDown(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerDownEvent(Link, e));
        }
    }

    private async Task HandlePointerUp(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerUpEvent(Link, e));
        }
    }

    private async Task HandlePointerLeave(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerLeaveEvent(Link, e));
        }
    }

    private async Task HandlePointerEnter(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerEnterEvent(Link, e));
        }
    }

    private async Task HandlePointerMove(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerMoveEvent(Link, e));
        }
    }

    private int RelativeX1 => Link.SourcePort.GetCenterCoordinates().CenterX - Container.PositionX;
    private int RelativeY1 => Link.SourcePort.GetCenterCoordinates().CenterY - Container.PositionY;
    private int RelativeX2 => Container.TargetX - Container.PositionX;
    private int RelativeY2 => Container.TargetY - Container.PositionY;
    
    private string GetPath()
    {
        switch (DefaultLinkComponentPathType)
        {
            case DefaultLinkComponentPathType.Curved:

                // Calculate control points for a single sine wave
                var control1X = (RelativeX1 + RelativeX2) / 2;
                var control1Y = RelativeY1 - WaveHeight; // control point above the line
                var control2X = (RelativeX1 + RelativeX2) / 2;
                var control2Y = RelativeY2 + WaveHeight; // control point below the line

                // Using a simple cubic BÃ©zier curve to draw a single wave
                return $"M {RelativeX1} {RelativeY1} C {control1X} {control1Y}, {control2X} {control2Y}, {RelativeX2} {RelativeY2}";
            case DefaultLinkComponentPathType.Line:
                return $"M {RelativeX1} {RelativeY1} L {RelativeX2} {RelativeY2}";
            case DefaultLinkComponentPathType.Orthogonal:
                var sourceX = RelativeX1;
                var sourceY = RelativeY1;
                var targetX = RelativeX2;
                var targetY = RelativeY2;

                var midX = (sourceX + targetX) / 2;
                return $"M {sourceX} {sourceY} " +
                       $"H {midX} " +
                       $"V {targetY} " +
                       $"H {targetX}";
                case DefaultLinkComponentPathType.Custom:
                    ArgumentNullException.ThrowIfNull(CustomLinkPath);
                    return CustomLinkPath.Invoke();
            default:
                throw new NotSupportedException();
        }
    }

    /// <inheritdoc />
    public void Dispose()
    {
       _subcriptions.DisposeAll();
    }

}