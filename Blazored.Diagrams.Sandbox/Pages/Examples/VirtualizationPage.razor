@page "/virtualization-overview"

<MudGrid Spacing="2" Justify="Justify.Center" Style="height:100%; width: 100%; margin: 0;">

    <!-- LEFT PANEL: Documentation -->
    <MudItem xs="12" sm="4" Style="height: 100%; overflow-y: auto;">
        <MudPaper Class="pa-4 mud-height-full">
            <MudText Typo="Typo.h5" Color="Color.Primary" GutterBottom="true">Performance & Virtualization</MudText>
            
            <MudExpansionPanels MultiExpansion="false">
                
                <!-- Panel 1: The Challenge -->
                <MudExpansionPanel Text="The Challenge with Large Diagrams" Expanded="true">
                    <MudText Typo="Typo.body1" Class="mb-2">
                        Rendering thousands of interactive elements (nodes, ports, links) in a browser is extremely performance-intensive.
                    </MudText>
                    <MudText Typo="Typo.body2" Class="mb-2">
                        Without optimization, the browser's DOM becomes bloated, and simple actions like panning or zooming can cause significant lag as every single element has to be re-calculated and re-drawn, even if it's not visible.
                    </MudText>
                </MudExpansionPanel>

                <!-- Panel 2: What is Virtualization? -->
                <MudExpansionPanel Text="What is Virtualization?" Expanded="true">
                    <MudText Typo="Typo.body1" Class="mb-2">
                        Virtualization is the solution to this problem. When enabled, the diagram constantly tracks the visible area of the viewport (factoring in pan and zoom).
                    </MudText>
                    <MudText Typo="Typo.body2" Class="mb-2">
                        It will only render the models (nodes, groups, links, ports) that are **currently inside or near this visible area**. Models that are far off-screen are not rendered to the DOM at all, saving immense processing power.
                    </MudText>
                    <MudAlert Severity="Severity.Info" Class="mb-3">
                        As you pan and zoom, models are dynamically added and removed from the DOM, but the full dataset remains in memory.
                    </MudAlert>
                </MudExpansionPanel>

                <!-- Panel 3: How to Enable Virtualization -->
                <MudExpansionPanel Text="How to Enable Virtualization" Expanded="true">
                    <MudText Typo="Typo.body1" Class="mb-2">
                        Enabling virtualization is done by setting the  <CodeHighlighter Language="csharp" Code="@($"{nameof(Service.Options.Virtualization.IsEnabled)}")"></CodeHighlighter> property to true on <CodeHighlighter Language="csharp" Code="Service.Options.Virtualization"></CodeHighlighter>
                    </MudText>
                    <MudSwitch
                        T="bool"
                        Label="Virtualization Enabled"
                        @bind-Value="Service.Options.Virtualization.IsEnabled"
                        ></MudSwitch>
                </MudExpansionPanel>
                
            </MudExpansionPanels>
        </MudPaper>
    </MudItem>

    <!-- RIGHT PANEL: Diagram with Virtualization -->
    <MudItem xs="12" sm="8" Style="height: 100%;">
        @if (!_loading)
        {
        <MudPaper Class="mud-height-full" Elevation="4" Style="position: relative;">
            <DiagramContainer DiagramService="Service"></DiagramContainer>
        </MudPaper>
        }
        else
        {
            <MudPaper Class="mud-height-full" Elevation="4" Style="position: relative;">
                <MudProgressCircular Size="Size.Large" Indeterminate="true"></MudProgressCircular>
                <MudText Typo="Typo.body1" Class="mb-2" Align="Align.Center">
                Loading...
                </MudText>
            </MudPaper>
        }
       
    </MudItem>

</MudGrid>

@code {
    [Inject] public IDiagramService Service { get; set; } = null!;
    private bool _loading = true;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await Task.Run(async () =>
            {
                int gridWidth = 25;
                int gridHeight = 25;
                int nodeWidth = 100;
                int nodeHeight = 100;
                int spacing = 25;

                Dictionary<string, Node> nodes = new();

                // 1. Create all nodes
                for (int y = 0; y < gridHeight; y++)
                {
                    for (int x = 0; x < gridWidth; x++)
                    {
                        var node = new Node();
                        node.SetPosition(x * (nodeWidth + spacing), y * (nodeHeight + spacing));
                        node.SetSize(nodeWidth, nodeHeight);
                
                        // Add ports
                        Service.AddPortTo(node, new Port { Alignment = PortAlignment.Top });
                        Service.AddPortTo(node, new Port { Alignment = PortAlignment.Bottom });

                        nodes.Add($"{x},{y}", node);
                        Service.AddNode(node);
                    }
                }

                // 2. Create links (9,900 links)
                // Link each node's bottom port to the top port of the node below it
                for (int y = 0; y < gridHeight - 1; y++)
                {
                    for (int x = 0; x < gridWidth; x++)
                    {
                        var nodeTop = nodes[$"{x},{y}"];
                        var nodeBottom = nodes[$"{x},{y+1}"];

                        var sourcePort = nodeTop.Ports.First(p => p.Alignment == PortAlignment.Bottom);
                        var targetPort = nodeBottom.Ports.First(p => p.Alignment == PortAlignment.Top);
                
                        Service.AddLinkTo(sourcePort, targetPort, new LineLink());
                    }
                }

                _loading = false;
                await InvokeAsync(StateHasChanged);
            });
        }
        
        await base.OnAfterRenderAsync(firstRender);
    }

    // --- Code Snippets ---

    private const string UsageCode =
@"<!-- In your .razor file -->

<DiagramContainer DiagramService=""MyDiagramService"" VirtualizationEnabled=""true"">
    
    <!-- Child controls (like Zoom or Minimap) work normally -->
    <ZoomControls />

</DiagramContainer>";
}
