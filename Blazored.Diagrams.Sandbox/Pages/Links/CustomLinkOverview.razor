@page "/custom-links"

<MudContainer MaxWidth="MaxWidth.False" Style="height:100%; padding-top: 20px;">
    <MudGrid Style="height:100%">

        <MudItem xs="12" sm="12" md="6" Style="height:100%;">
            <MudPaper Class="pa-4 mud-height-full d-flex flex-column overflow-y-auto" Elevation="4">
                <MudText Typo="Typo.h4" Color="Color.Primary" Class="mb-4">Custom Link Implementation</MudText>

                <MudText Typo="Typo.body1" Class="mb-4">
                    Creating custom links involves two parts: a **C# model** that inherits from <code>Link</code>, and a **Razor component** that renders the SVG path. Remember, your component **must** include a parameter for the <code class="mud-code">Link</code> model!
                </MudText>

                <MudExpansionPanels MultiExpansion="true">

                    <MudExpansionPanel Text="The Custom Link Model (C#)" Expanded="true">
                        <MudText Typo="Typo.body1" Class="mb-4">
                            Define your new link type by inheriting from the base <code>Link</code> class and implementing the <code>IHasComponent&lt;T&gt;</code> interface to link it to your Razor component. The model needs a constructor to satisfy its base class.
                        </MudText>
                        <CodeHighlighter Language="csharp" Code="@CustomLinkModelCode" />
                        <MudText Typo="Typo.body1" Class="mb-4">
                            The component you create can be done in two ways:
                            1) Inherit from DefaultLinkComponent and use/override the basic features.
                            2) Implement your own link component from scratch.
                        </MudText>
                    </MudExpansionPanel>

                    <MudExpansionPanel Text="Extending the Default Component" Expanded="false">
                        <MudText Typo="Typo.body1" Class="mb-4">
                            For a custom path or minor styling changes, it's easiest to **inherit from <code>DefaultLinkComponent</code>**. This gives you access to pre-calculated coordinates (<code>RelativeX1</code>, etc.) and built-in event handling. We'll use this to create a simple S-shaped curved link.
                        </MudText>
                        <CodeHighlighter Language="cshtml" Code="@ExtendedLinkComponentCode" />
                    </MudExpansionPanel>

                    <MudExpansionPanel Text="Totally Custom Component (Animated)" Expanded="false">
                        <MudText Typo="Typo.body1" Class="mb-4">
                            For advanced features like animation  or custom decorations, you can create a component that **does not inherit from <code>DefaultLinkComponent</code>**. You'll need to handle coordinates and interactivity yourself, but it gives maximum flexibility.
                        </MudText>
                        <CodeHighlighter Language="cshtml" Code="@AnimatedLinkComponentCode" />
                    </MudExpansionPanel>

                    <MudExpansionPanel Text="Initialization" Expanded="false">
                        <MudText Typo="Typo.body1" Class="mb-4">
                            Once your link models and components are ready, use them just like the built-in links to
                            connect ports using the explicit `Service.AddAddLinkTo` method.
                        </MudText>
                        <CodeHighlighter Language="csharp" Code="@LinkInitializationCode" />
                    </MudExpansionPanel>

                </MudExpansionPanels>

            </MudPaper>
        </MudItem>

        <MudItem xs="12" sm="12" md="6" Style="height:100%">
            <MudPaper Class="mud-height-full" Elevation="4">
                <DiagramContainer DiagramService="Service" />
            </MudPaper>
        </MudItem>

    </MudGrid>
</MudContainer>

@code {
    [Inject]
    public IDiagramService Service { get; set; } = null!;
    
    protected override Task OnInitializedAsync()
    {
        // 1. Create Nodes
        var n1 = new Node { PositionX = 50, PositionY = 100  };
        var n2 = new Node { PositionX = 300, PositionY = 50  };
        var n3 = new Node { PositionX = 301, PositionY = 300 };

        // Set size for all nodes (for better visual appeal)
        n1.SetSize(140, 50);
        n2.SetSize(140, 50);
        n3.SetSize(140, 50);

        // 2. Add Nodes
        Service.AddNode(n1);
        Service.AddNode(n2);
        Service.AddNode(n3);

        // 3. Create Ports for Links

        // Ports for the Extended Link (n1 -> n3)
        Service.AddPortTo(n1, new Port { Alignment = PortAlignment.Right });
        Service.AddPortTo(n3, new Port { Alignment = PortAlignment.Left });

        // Ports for the Animated Link (n2 -> n3)
        Service.AddPortTo(n2, new Port { Alignment = PortAlignment.Bottom });
        Service.AddPortTo(n3, new Port { Alignment = PortAlignment.Top });
        
        var extendedLink = new ExtendedLink(); 
        var animatedLink = new AnimatedLink();


        // 5. Add Links by connecting specific ports

        // Link 1: ExtendedLink (n1 Right -> n3 Left)
        var n1RightPort = n1.Ports.First(p => p.Alignment == PortAlignment.Right);
        var n3LeftPort = n3.Ports.First(p => p.Alignment == PortAlignment.Left);
        Service.AddLinkTo(n1RightPort, n3LeftPort, extendedLink);

        // Link 2: AnimatedLink (n2 Bottom -> n3 Top)
        var n2BottomPort = n2.Ports.First(p => p.Alignment == PortAlignment.Bottom);
        var n3TopPort = n3.Ports.First(p => p.Alignment == PortAlignment.Top);
        Service.AddLinkTo(n2BottomPort, n3TopPort, animatedLink);

        return base.OnInitializedAsync();
    }

    // --- Code Strings for the Expansion Panels ---

    private const string CustomLinkModelCode = @"
/// <summary>
/// A link model that uses the ExtendedLinkComponent, which inherits from DefaultLinkComponent.
/// This allows for easy path customization while keeping built-in events and styling.
/// </summary>
public class ExtendedLink : Link, IHasComponent<ExtendedLinkComponent>;

/// <summary>
/// A link model that uses the AnimatedLinkComponent, a totally custom component.
/// This is for full control over rendering, including SVG animation effects.
/// </summary>
public class AnimatedLink : Link, IHasComponent<AnimatedLinkComponent>;
";

    private const string ExtendedLinkComponentCode = @"
@inherits DefaultLinkComponent

@*
    We call the base component's render tree. This automatically renders the <svg> container,
    the <path> element with event listeners, selection logic, and the default glow effect.
    We just override the logic in the @code block.
*@
@{ base.BuildRenderTree(__builder); }

@code {
    // IMPORTANT: The Link parameter is mandatory.
    public new ExtendedLink Link { get; set; } = null!;

    // Override GetPath() to draw a custom SVG path (an S-curve)
    protected override string GetPath()
    {
        // RelativeX1/Y1 and RelativeX2/Y2 are provided by the base DefaultLinkComponent
        var control1X = RelativeX1 + 50; // Offset control point from start X
        var control1Y = RelativeY1;      // Keep control point Y at start Y
        var control2X = RelativeX2 - 50; // Offset control point from end X
        var control2Y = RelativeY2;      // Keep control point Y at end Y

        // Cubic Bezier curve path definition
        return $""M {RelativeX1} {RelativeY1} C {control1X} {control1Y}, {control2X} {control2Y}, {RelativeX2} {RelativeY2}"";
    }

    // Override the stroke color for visual distinction
    protected override string StrokeColor { get; set; } = ""#009688""; // Teal

    // Override selected color to match the teal theme
    protected override string SelectedStrokeColor { get; set; } = ""#4db6ac""; // Lighter Teal
    // Override stroke to be double the normal width.
    protected override int StrokeWidth { get; set; } = 8;
}";

    private const string AnimatedLinkComponentCode = @"
<style>
.animated-link {
    width: 100%;
    height: 100%;
    overflow: visible;
    pointer-events: none; /* Allows clicks to fall through to the path */
}

.animated-path {
    pointer-events: auto; /* Re-enable pointer events on the path itself */
    stroke-linecap: round;
    transition: stroke 0.2s, stroke-width 0.2s;

    /* Animation properties: 'marching ants' effect */
    animation: dash 5s linear infinite;
}

.animated-path.selected {
    stroke-width: 6; /* Thicker when selected */
    filter: drop-shadow(0 0 5px #ffc107);
}

@@keyframes dash {
     to {
         stroke-dashoffset: -100;
     }
 }
</style>
<svg class=""animated-link"">
    @* The d attribute defines a straight path with a dashed, animated stroke *@
    <path d=""@Path""
          fill=""none""
          id=""@PathId""
          stroke=""@Stroke""
          stroke-width=""4""
          stroke-dasharray=""10, 5""
          class=""animated-path @(Link.IsSelected ? ""selected"" : """")""
          @onpointerleave=""HandlePointerLeave""
          @onpointerdown=""HandlePointerDown""
          @onpointerenter=""HandlePointerEnter""
          @onpointermove=""HandlePointerMove""
          @onpointerup=""HandlePointerUp""
          @onwheel=""ctx => DiagramService.Events.Publish(new LinkWheelEvent(Link, ctx))""
          @onclick=""HandleClick""
          @ondblclick=""HandleDoubleClick""/>
</svg>

@code {
     [Inject] private IJSRuntime Js { get; init; } = null!;

    // MANDATORY LINK PARAMETER: Required to receive the model data
    [Parameter] public required AnimatedLink Link { get; set; }

    // Get the container position for relative coordinate calculation
    [CascadingParameter] public LinkContainer Container { get; set; }
    
    /// <summary>
    /// Service cascaded through the <see cref=""LinkContainer""/>
    /// </summary>
    [CascadingParameter]
    public IDiagramService DiagramService { get; init; } = null!;

    /// <summary>
        ///     ID of the element.
        /// </summary>
        private string PathId => $""link-path-{Link.Id}"";

    private string Stroke => Link.IsSelected ? ""#ffc107"" : ""#ff5722""; // Orange/Amber

    private string Path => GetPath();


    private string GetPath()
    {
        // Calculate the absolute positions of source and target
        var sourceX = Link.SourcePort.GetCenterCoordinates().CenterX;
        var sourceY = Link.SourcePort.GetCenterCoordinates().CenterY;
        var targetX = Container.TargetX;
        var targetY = Container.TargetY;

        // Convert to coordinates relative to the LinkContainer
        var relativeX1 = sourceX - Container.PositionX;
        var relativeY1 = sourceY - Container.PositionY;
        var relativeX2 = targetX - Container.PositionX;
        var relativeY2 = targetY - Container.PositionY;

        // Simple straight line path
        return $""M {relativeX1} {relativeY1} L {relativeX2} {relativeY2}"";
    }


    /// <summary>
    /// Handles the @onclick event.
    /// </summary>
    /// <param name=""e"">Mouse event args.</param>
    protected virtual async Task HandleClick(MouseEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkClickedEvent(Link, e));
        }
    }

    /// <summary>
    /// Handles the @ondbclick event.
    /// </summary>
    /// <param name=""e"">Mouse event args.</param>
    protected virtual async Task HandleDoubleClick(MouseEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkDoubleClickedEvent(Link, e));
        }
    }

    /// <summary>
    /// Handles the @onpointerdown event.
    /// </summary>
    /// <param name=""e"">Mouse event args.</param>
    protected virtual async Task HandlePointerDown(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerDownEvent(Link, e));
        }
    }

    /// <summary>
    /// Handles the @onpointerup event.
    /// </summary>
    /// <param name=""e"">Mouse event args.</param>
    protected virtual async Task HandlePointerUp(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerUpEvent(Link, e));
        }
    }

    /// <summary>
    /// Handles the @onpointerleave event.
    /// </summary>
    /// <param name=""e"">Mouse event args.</param>
    protected virtual async Task HandlePointerLeave(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerLeaveEvent(Link, e));
        }
    }

    /// <summary>
    /// Handles the @onpointerenter event.
    /// </summary>
    /// <param name=""e"">Mouse event args.</param>
    protected virtual async Task HandlePointerEnter(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerEnterEvent(Link, e));
        }
    }

    /// <summary>
    /// Handles the @onpointermove event.
    /// </summary>
    /// <param name=""e"">Mouse event args.</param>
    protected virtual async Task HandlePointerMove(PointerEventArgs e)
    {
        if (await Js.IsClickOnPath(e, PathId))
        {
            DiagramService.Events.Publish(new LinkPointerMoveEvent(Link, e));
        }
    }";

    private const string LinkInitializationCode = @"
using Blazored.Diagrams.Ports;
using System.Linq;
using Blazored.Diagrams.Sandbox.Customs; // Assuming custom models are here

protected override Task OnInitializedAsync()
{
    // 1. Create Nodes
    var n1 = new Node { PositionX = 50, PositionY = 100, Title = ""Source 1"" };
    // ... create n2, n3 ...

    // 2. Add Nodes
    Service.AddNode(n1);
    // ... add n2, n3 ...

    // 3. Create Ports explicitly
    Service.AddPortTo(n1, new Port { Alignment = PortAlignment.Right });
    Service.AddPortTo(n3, new Port { Alignment = PortAlignment.Left });

    // 4. Create Link Models
    // Using the models and their required constructors
    var extendedLink = new ExtendedLink();
    var animatedLink = new AnimatedLink();


    // 5. Add Links by connecting specific ports
    var n1RightPort = n1.Ports.First(p => p.Alignment == PortAlignment.Right);
    var n3LeftPort = n3.Ports.First(p => p.Alignment == PortAlignment.Left);
    var n2BottomPort = n2.Ports.First(p => p.Alignment == PortAlignment.Bottom);
    var n3TopPort = n3.Ports.First(p => p.Alignment == PortAlignment.Top);
    
    // Pass the ports and the model to AddLinkTo
    Service.AddAddLinkTo(n1RightPort, n3LeftPort, extendedLink);
    Service.AddAddLinkTo(n2BottomPort, n3TopPort, animatedLink);    

    return base.OnInitializedAsync();
}
";
}
